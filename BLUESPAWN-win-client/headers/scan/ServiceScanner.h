#pragma once

#include <unordered_map>
#include <string>

#include "scan/Detections.h"
#include "scan/Scanner.h"

class ServiceScanner : public Scanner {
public:

	/**
	 * Gets a vector of detections associated with the provided detection. This is done by finding the associated
	 * registry entry and all associated files
	 *
	 * @param detection The detection for which associations will be found
	 *
	 * @return A vector of detections associated with the provided detection
	 */
	virtual std::unordered_map<std::shared_ptr<Detection>, Association> GetAssociatedDetections(
		IN CONST Detection& detection
	);

	/**
	 * Performs a quick scan on the specified service to determine if it may be malicious. This is done by checking
	 * if the service path referenced by the service refers to a signed binary or if the service name / display name
	 * appear potentially malicious. At least one argument must be present.
	 *
	 * @param ServiceName The name of the service, if known. If not known, this may be set to nullopt
	 * @param ServiceDisplayName The display name of the service, if known. If not known, this may be set to nullopt
	 * @param ServicePath The path to the service executable, if known. If not known, this may be set to nullopt
	 *
	 * @return true if the service may be malicious, false otherwise
	 */
	static bool PerformQuickScan(
		IN CONST std::optional<std::wstring>& ServiceName,
		IN CONST std::optional<std::wstring>& ServiceDisplayName,
		IN CONST std::optional<std::wstring>& ServicePath = std::nullopt OPTIONAL
	);

	/**
	 * Scans a detection and returns the certainty that the detection is malicious. This is done by checking service 
	 * names that meet certain properties, are known to have malicious uses, or appear generated by common offensive
	 * tools
	 *
	 * @param detection The Detection object to scan
	 *
	 * @return A Certainty indicating the degree of certainty for which the detection is malicious
	 */
	virtual Certainty ScanDetection(
		IN CONST Detection& detection
	);
};